package com.example.smartworks.auth;

import android.content.Context;
import android.content.SharedPreferences;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;
import com.google.gson.Gson;
import com.google.gson.annotations.SerializedName;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import okhttp3.*;

/**
 * AuthenticationManagerDemo - Demo backup version
 */
public class AuthenticationManagerDemo {
    private static final String TAG = "AuthManager";
    private static final String PREFS_NAME = "SmartWorksAuth"; // FIXED: Now matches MainActivity
    private static final String BASE_URL = "https://httpbin.org/"; // Test URL - replace with your server
    
    // Preference keys - FIXED: Now matches MainActivity exactly
    private static final String KEY_USER_ID = "user_id";
    private static final String KEY_USERNAME = "username";
    private static final String KEY_EMAIL = "email";
    private static final String KEY_API_KEY = "api_key";
    private static final String KEY_ROLE = "role";
    private static final String KEY_IS_LOGGED_IN = "is_logged_in";
    
    private static AuthenticationManagerDemo instance;
    private final Context context;
    private final OkHttpClient httpClient;
    private final Gson gson;
    private final ExecutorService executorService;
    private SharedPreferences prefs;
    
    // User data
    private User currentUser;
    
    private AuthenticationManagerDemo(Context context) {
        try {
            this.context = context.getApplicationContext();
            this.gson = new Gson();
            this.executorService = Executors.newCachedThreadPool();
            
            // FIXED: Use same preference name as MainActivity
            this.prefs = context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE);
            
            // Initialize OkHttp with conservative timeouts
            this.httpClient = new OkHttpClient.Builder()
                    .connectTimeout(5, java.util.concurrent.TimeUnit.SECONDS)
                    .readTimeout(10, java.util.concurrent.TimeUnit.SECONDS)
                    .writeTimeout(10, java.util.concurrent.TimeUnit.SECONDS)
                    .build();
            
            loadUserData();
            Log.d(TAG, "AuthenticationManager initialized successfully");
            
        } catch (Exception e) {
            Log.e(TAG, "Error initializing AuthenticationManager", e);
            throw new IllegalStateException("Failed to initialize AuthenticationManager", e);
        }
    }
    
    public static synchronized AuthenticationManagerDemo getInstance(Context context) {
        try {
            if (instance == null) {
                instance = new AuthenticationManagerDemo(context);
            }
            return instance;
        } catch (Exception e) {
            Log.e(TAG, "Error getting AuthenticationManagerDemo instance", e);
            throw new IllegalStateException("Cannot create AuthenticationManagerDemo", e);
        }
    }
    
    private void loadUserData() {
        try {
            if (prefs.getBoolean(KEY_IS_LOGGED_IN, false)) {
                currentUser = new User();
                currentUser.id = prefs.getInt(KEY_USER_ID, 0);
                currentUser.username = prefs.getString(KEY_USERNAME, "");
                currentUser.email = prefs.getString(KEY_EMAIL, "");
                currentUser.apiKey = prefs.getString(KEY_API_KEY, "");
                currentUser.role = prefs.getString(KEY_ROLE, "user");
                Log.d(TAG, "Loaded user data for: " + currentUser.username);
            }
        } catch (Exception e) {
            Log.e(TAG, "Error loading user data", e);
            currentUser = null;
        }
    }
    
    private void saveUserData(User user) {
        try {
            SharedPreferences.Editor editor = prefs.edit();
            editor.putBoolean(KEY_IS_LOGGED_IN, true);
            editor.putInt(KEY_USER_ID, user.id);
            editor.putString(KEY_USERNAME, user.username);
            editor.putString(KEY_EMAIL, user.email);
            editor.putString(KEY_API_KEY, user.apiKey);
            editor.putString(KEY_ROLE, user.role);
            boolean saved = editor.commit(); // Use commit for immediate result
            
            if (saved) {
                this.currentUser = user;
                Log.d(TAG, "User data saved successfully for: " + user.username);
                
                // Debug: Verify the data was saved
                boolean checkLogin = prefs.getBoolean(KEY_IS_LOGGED_IN, false);
                String checkUsername = prefs.getString(KEY_USERNAME, "");
                Log.d(TAG, "Verification - isLoggedIn: " + checkLogin + ", username: " + checkUsername);
            } else {
                Log.e(TAG, "Failed to save user data");
            }
        } catch (Exception e) {
            Log.e(TAG, "Error saving user data", e);
        }
    }
    
    private void clearUserData() {
        try {
            SharedPreferences.Editor editor = prefs.edit();
            editor.clear();
            boolean cleared = editor.commit();
            this.currentUser = null;
            Log.d(TAG, "User data cleared: " + cleared);
        } catch (Exception e) {
            Log.e(TAG, "Error clearing user data", e);
        }
    }
    
    /**
     * Login with username and password - DEMO VERSION
     */
    public CompletableFuture<AuthResult> login(String username, String password) {
        CompletableFuture<AuthResult> future = new CompletableFuture<>();
        
        try {
            Log.d(TAG, "Attempting login for user: " + username);
            
            // DEMO: Skip actual network call and simulate login
            executorService.execute(() -> {
                try {
                    // Simulate network delay
                    Thread.sleep(1000);
                    
                    // Demo validation - accept any non-empty username/password
                    if (username != null && !username.trim().isEmpty() && 
                        password != null && !password.trim().isEmpty()) {
                        
                        // Create demo user
                        User user = new User();
                        user.id = 1;
                        user.username = username.trim();
                        user.email = username.trim() + "@demo.com";
                        user.apiKey = "demo_api_key_" + System.currentTimeMillis();
                        user.role = "user";
                        
                        saveUserData(user);
                        future.complete(AuthResult.success("Login successful (Demo Mode)", user));
                        
                        Log.d(TAG, "Demo login successful for: " + username);
                    } else {
                        future.complete(AuthResult.error("Username and password are required"));
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Login error", e);
                    future.complete(AuthResult.error("Login failed: " + e.getMessage()));
                }
            });
            
        } catch (Exception e) {
            Log.e(TAG, "Error starting login process", e);
            future.complete(AuthResult.error("System error during login"));
        }
        
        return future;
    }
    
    /**
     * Register new user - DEMO VERSION
     */
    public CompletableFuture<AuthResult> register(String username, String email, String password) {
        CompletableFuture<AuthResult> future = new CompletableFuture<>();
        
        try {
            executorService.execute(() -> {
                try {
                    // Simulate network delay
                    Thread.sleep(1000);
                    
                    // Demo validation
                    if (username != null && !username.trim().isEmpty() && 
                        email != null && !email.trim().isEmpty() && 
                        password != null && password.length() >= 6) {
                        
                        future.complete(AuthResult.success("Registration successful (Demo). Please login."));
                        Log.d(TAG, "Demo registration successful for: " + username);
                    } else {
                        future.complete(AuthResult.error("Invalid registration data"));
                    }
                    
                } catch (Exception e) {
                    Log.e(TAG, "Registration error", e);
                    future.complete(AuthResult.error("Registration failed: " + e.getMessage()));
                }
            });
            
        } catch (Exception e) {
            Log.e(TAG, "Error starting registration process", e);
            future.complete(AuthResult.error("System error during registration"));
        }
        
        return future;
    }
    
    /**
     * Request password reset - DEMO VERSION
     */
    public CompletableFuture<AuthResult> requestPasswordReset(String email) {
        CompletableFuture<AuthResult> future = new CompletableFuture<>();
        
        try {
            executorService.execute(() -> {
                try {
                    // Simulate network delay
                    Thread.sleep(500);
                    future.complete(AuthResult.success("Password reset email sent (Demo)"));
                } catch (Exception e) {
                    future.complete(AuthResult.error("Password reset failed: " + e.getMessage()));
                }
            });
        } catch (Exception e) {
            future.complete(AuthResult.error("System error during password reset"));
        }
        
        return future;
    }
    
    /**
     * Logout current user
     */
    public void logout() {
        try {
            clearUserData();
            Log.d(TAG, "User logged out");
        } catch (Exception e) {
            Log.e(TAG, "Error during logout", e);
        }
    }
    
    /**
     * Check if user is logged in
     */
    public boolean isLoggedIn() {
        try {
            boolean loggedIn = currentUser != null && 
                             currentUser.username != null && 
                             !currentUser.username.trim().isEmpty();
            Log.d(TAG, "Login check: " + loggedIn + " (user: " + 
                  (currentUser != null ? currentUser.username : "null") + ")");
            return loggedIn;
        } catch (Exception e) {
            Log.e(TAG, "Error checking login status", e);
            return false;
        }
    }
    
    /**
     * Get current user
     */
    public User getCurrentUser() {
        return currentUser;
    }
    
    /**
     * Get API key for authenticated requests
     */
    public String getApiKey() {
        return currentUser != null ? currentUser.apiKey : null;
    }
    
    /**
     * Get user ID for authenticated requests
     */
    public int getUserId() {
        return currentUser != null ? currentUser.id : 0;
    }
    
    /**
     * Validate current session - DEMO VERSION
     */
    public CompletableFuture<Boolean> validateSession() {
        CompletableFuture<Boolean> future = new CompletableFuture<>();
        
        try {
            if (!isLoggedIn()) {
                future.complete(false);
                return future;
            }
            
            executorService.execute(() -> {
                try {
                    // Demo: just check if user data exists
                    boolean valid = currentUser != null && 
                                  currentUser.username != null && 
                                  !currentUser.username.trim().isEmpty();
                    future.complete(valid);
                } catch (Exception e) {
                    Log.e(TAG, "Session validation error", e);
                    future.complete(false);
                }
            });
            
        } catch (Exception e) {
            Log.e(TAG, "Error starting session validation", e);
            future.complete(false);
        }
        
        return future;
    }
    
    // Data classes for API communication
    public static class User {
        public int id;
        public String username;
        public String email;
        public String apiKey;
        public String role;
        
        public boolean isAdmin() {
            return "admin".equals(role);
        }
    }
    
    public static class AuthResult {
        public final boolean success;
        public final String message;
        public final User user;
        
        private AuthResult(boolean success, String message, User user) {
            this.success = success;
            this.message = message;
            this.user = user;
        }
        
        public static AuthResult success(String message) {
            return new AuthResult(true, message, null);
        }
        
        public static AuthResult success(String message, User user) {
            return new AuthResult(true, message, user);
        }
        
        public static AuthResult error(String message) {
            return new AuthResult(false, message, null);
        }
    }
    
    /**
     * Interface for authentication state changes
     */
    public interface AuthStateListener {
        void onAuthStateChanged(boolean isLoggedIn, User user);
    }
    
    // Auth state listeners
    private java.util.List<AuthStateListener> authStateListeners = new java.util.ArrayList<>();
    
    public void addAuthStateListener(AuthStateListener listener) {
        try {
            if (listener != null) {
                authStateListeners.add(listener);
            }
        } catch (Exception e) {
            Log.e(TAG, "Error adding auth state listener", e);
        }
    }
    
    public void removeAuthStateListener(AuthStateListener listener) {
        try {
            authStateListeners.remove(listener);
        } catch (Exception e) {
            Log.e(TAG, "Error removing auth state listener", e);
        }
    }
    
    private void notifyAuthStateChanged(boolean isLoggedIn, User user) {
        try {
            Handler mainHandler = new Handler(Looper.getMainLooper());
            mainHandler.post(() -> {
                try {
                    for (AuthStateListener listener : authStateListeners) {
                        listener.onAuthStateChanged(isLoggedIn, user);
                    }
                } catch (Exception e) {
                    Log.e(TAG, "Error notifying auth state change", e);
                }
            });
        } catch (Exception e) {
            Log.e(TAG, "Error setting up auth state notification", e);
        }
    }
}